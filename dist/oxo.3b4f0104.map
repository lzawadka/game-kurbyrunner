{"version":3,"sources":["js/libs/oxo.js"],"names":["window","oxo","width","innerWidth","height","innerHeight","animation","move","element","direction","distance","allowOutside","position","getPosition","newPosition","computeNewPosition","elPos","getBoundingClientRect","x","y","elements","obstacles","length","elFuturePos","Object","assign","every","obstacle","elementsAreColliding","setPosition","console","error","style","transform","match","RegExp","values","map","value","parseInt","replace","translation","getMovableElement","movableElement","document","querySelector","speed","getAttribute","moveElementWithArrowKeys","interval","pressed","pixels","Math","round","log","addEventListener","event","key","indexOf","toLowerCase","push","setInterval","requestAnimationFrame","inputs","getDirectionFromPressedKeys","filter","clearInterval","createElement","params","type","class","split","forEach","className","classList","add","styles","appendElement","appendTo","hostSelector","host","body","appendChild","onLeaveScreen","action","completly","once","observer","IntersectionObserver","entries","entry","isIntersecting","disconnect","root","rootMargin","threshold","observe","onLeaveScreenOnce","onCollisionWithElement","target","colliding","onCollisionWithElementOnce","element1Pos","element2Pos","keys","enter","space","left","up","right","down","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","z","keysListeners","listenKey","code","bind","listenKeys","listenArrowKeys","listenKeyOnce","cancelKeyListener","cancelKeysListeners","cancelKeysListener","cancelArrowKeysListeners","listenAllKeys","listener","keyCode","dir","dirPart","player","addToScore","points","setScore","getScore","localStorage","getItem","removeFromScore","newScore","max","setItem","refreshScore","scoreElement","getElement","innerText","screens","currentScreen","loadScreen","name","fetch","then","response","ok","text","html","innerHTML","setAttribute","call","getCurrentScreen","utils","getRandomNumber","min","floor","random","init","message","attribute"],"mappings":";AAAAA,OAAOC,IAAM,CACXA,IAAK,KACLC,MAAOF,OAAOG,WACdC,OAAQJ,OAAOK,YAEfC,UAAW,CASTC,KAAKC,SAAAA,EAASC,EAAWC,EAAUC,GAC7B,GAACH,EAKD,GAACE,EAAD,CAKAE,IAAAA,EAAWX,IAAIK,UAAUO,YAAYL,GACrCM,EAAcb,IAAIK,UAAUS,mBAC9BH,EACAH,EACAC,GAGEM,EAAQR,EAAQS,wBAEhB,GAACN,KAEDG,EAAYI,EAAIF,EAAMd,MAAQD,IAAIC,OAClCY,EAAYI,EAAI,GAChBJ,EAAYK,EAAIH,EAAMZ,OAASH,IAAIG,QACnCU,EAAYK,EAAI,GALhB,CAWAlB,GAAAA,IAAImB,SAASC,UAAUC,OAAQ,CAC7BC,IAAAA,EAAcC,OAAOC,OAAOT,EAAO,CACrCE,EAAGJ,EAAYI,EACfC,EAAGL,EAAYK,IAIf,IAAClB,IAAImB,SAASC,UAAUK,MAAM,SAASC,GAEnCA,OAAAA,GAAYnB,IACXP,IAAImB,SAASQ,qBACZD,EAASV,wBACTM,KAKN,OAMGT,OAFPb,IAAIK,UAAUuB,YAAYrB,EAASM,GAE5BA,QA/CLgB,QAAQC,MAAM,uDALdD,QAAQC,MAAM,sCA6DlBhB,mBAAmBH,SAAAA,EAAUH,EAAWC,GAClCI,IAAAA,EAAcU,OAAOC,OAAO,GAAIb,GAE5BH,OAAAA,GACD,IAAA,OACHK,EAAYI,GAAKR,EACjB,MACG,IAAA,UACHI,EAAYK,GAAKT,EACjBI,EAAYI,GAAKR,EACjB,MACG,IAAA,KACHI,EAAYK,GAAKT,EACjB,MACG,IAAA,WACHI,EAAYK,GAAKT,EACjBI,EAAYI,GAAKR,EACjB,MACG,IAAA,QACHI,EAAYI,GAAKR,EACjB,MACG,IAAA,aACHI,EAAYI,GAAKR,EACjBI,EAAYK,GAAKT,EACjB,MACG,IAAA,OACHI,EAAYK,GAAKT,EACjB,MACG,IAAA,YACHI,EAAYK,GAAKT,EACjBI,EAAYI,GAAKR,EACjB,MACF,QAIE,YAHAoB,QAAQC,MACN,2BAA6BtB,EAAY,kBAKxCK,OAAAA,GAQTD,YAAYL,SAAAA,GACNI,IAAAA,EAAWJ,EAAQwB,MAAMC,UAAUC,MACrC,IAAIC,OAAO,oBAGTvB,GAAAA,EAAU,CACRwB,IAAAA,EAASxB,EAAS,GAAGsB,MAAM,UAAUG,IAAI,SAAAC,GAASC,OAAAA,SAASD,KACxD,MAAA,CACLpB,EAAGkB,EAAO,GACVjB,EAAGiB,EAAO,IAGL,MAAA,CAAElB,EAAG,EAAGC,EAAG,IAUtBU,YAAYrB,SAAAA,EAASI,GACfqB,IAAAA,EAAYzB,EAAQwB,MAAMC,UAAUO,QAAQ,kBAAmB,IAE/DC,EAAc,aAAe7B,EAASM,EAAI,OAASN,EAASO,EAAI,MAE5DX,OAAAA,EAAQwB,MAAMC,UAAYA,EAAYQ,GAOhDC,kBAAoB,WACdC,IAAAA,EAAiBC,SAASC,cAAc,sBAExCF,GAAAA,EAAgB,CACdG,IAAAA,EAAQH,EAAeI,aAAa,kBAIjCJ,OAHPG,EAAQA,GAAgB,GACxB7C,IAAIK,UAAU0C,yBAAyBL,EAAgBG,GAEhDH,IASXK,yBAAyBxC,SAAAA,EAASsC,GAC5BG,IAAAA,EACAC,EAAU,GACVC,EAASL,EAAQ,IAAMM,KAAKC,MAAMP,EAAQ,KAAO,EACrDhB,QAAQwB,IAAIH,GAEZP,SAASW,iBAAiB,UAAW,SAASC,GACxCA,GAA+B,IAA/BA,EAAMC,IAAIC,QAAQ,SAAgB,CAChCjD,IAAAA,EAAY+C,EAAMC,IAAIjB,QAAQ,QAAS,IAAImB,eAEX,IAAhCT,EAAQQ,QAAQjD,KAClByC,EAAQU,KAAKnD,GAERwC,IACHA,EAAWY,YAAY,WACrB7D,OAAO8D,sBAAsB,WACvBZ,EAAQ5B,QACVrB,IAAIK,UAAUC,KACZC,EACAP,IAAI8D,OAAOC,4BAA4Bd,GACvCC,GACA,MAIL,IAAML,QAMjBF,SAASW,iBAAiB,QAAS,SAASC,GACtCA,GAA+B,IAA/BA,EAAMC,IAAIC,QAAQ,SAAgB,CAChCjD,IAAAA,EAAY+C,EAAMC,IAAIjB,QAAQ,QAAS,IAAImB,eAE/CT,EAAUA,EAAQe,OAAO,SAAAR,GAAOA,OAAAA,IAAQhD,KAC3Ba,SACX4C,cAAcjB,GACdA,EAAW,WAOrB7B,SAAU,CACRC,UAAW,GAMX8C,cAAcC,SAAAA,GACR5D,IAAAA,EAAUoC,SAASuB,cAAcC,EAAOC,KAAOD,EAAOC,KAAO,OAQ7DD,GANAA,EAAOE,OACTF,EAAOE,MAAMC,MAAM,KAAKC,QAAQ,SAASC,GACvCjE,EAAQkE,UAAUC,IAAIF,KAItBL,EAAOQ,OACJ5C,IAAAA,SAASoC,EAAOQ,OACnBpE,EAAQwB,MAAMA,OAASoC,EAAOQ,OAAO5C,OAUlCxB,OANH4D,EAAOzC,UACT1B,IAAImB,SAASC,UAAUuC,KAAKpD,GAG9BP,IAAImB,SAASyD,cAAcrE,EAAS4D,EAAOU,UAEpCtE,GAQTqE,cAAcrE,SAAAA,EAASuE,GACjBC,IAAAA,EAAOD,EACPnC,SAASC,cAAckC,GACvBnC,SAASqC,KAERD,EAKLA,EAAKE,YAAY1E,GAJfsB,QAAQC,MAAM,sCAAuCgD,IAezDI,cAAc3E,SAAAA,EAAS4E,EAAQC,EAAWC,GACpCC,IAAAA,EAAW,IAAIC,qBACjB,SAASC,GACPA,EAAQjB,QAAQ,SAASkB,GAClBA,EAAMC,iBACTP,IAEIE,GACFC,EAASK,iBAKjB,CACEC,KAAM,KACNC,WAAY,MACZC,UAAWV,EAAY,EAAI,IAKxBE,OAFPA,EAASS,QAAQxF,GAEV+E,GAUTU,kBAAkBzF,SAAAA,EAAS4E,EAAQC,GAC1BpF,OAAAA,IAAImB,SAAS+D,cAAc3E,EAAS4E,EAAQC,GAAW,IAWhEa,uBAAuB1F,SAAAA,EAAS2F,EAAQf,EAAQE,GAC1Cc,IAAAA,GAAY,EAEZnD,EAAWY,YAAY,WAEvB5D,IAAImB,SAASQ,qBACXpB,EAAQS,wBACRkF,EAAOlF,yBAGJmF,IACHhB,IACAgB,GAAY,EAERd,GACFpB,cAAcjB,IAIlBmD,GAAY,GAEb,IAEInD,OAAAA,GAUToD,2BAA2B7F,SAAAA,EAAS2F,EAAQf,GACnCnF,OAAAA,IAAImB,SAAS8E,uBAAuB1F,EAAS2F,EAAQf,GAAQ,IAQtExD,qBAAqB0E,SAAAA,EAAaC,GAE9BD,OAAAA,EAAYpF,EAAIqF,EAAYrF,EAAIqF,EAAYrG,OAC5CoG,EAAYpF,EAAIoF,EAAYpG,MAAQqG,EAAYrF,GAChDoF,EAAYnF,EAAIoF,EAAYpF,EAAIoF,EAAYnG,QAC5CkG,EAAYlG,OAASkG,EAAYnF,EAAIoF,EAAYpF,IAKvD4C,OAAQ,CACNyC,KAAM,CACJC,MAAO,GACPC,MAAO,GACPC,KAAM,GACNC,GAAI,GACJC,MAAO,GACPC,KAAM,GACNC,EAAG,GACHC,EAAG,GACHC,EAAG,GACHC,EAAG,GACHC,EAAG,GACHC,EAAG,GACHC,EAAG,GACHC,EAAG,GACHC,EAAG,GACHC,EAAG,GACHC,EAAG,GACHC,EAAG,GACHC,EAAG,GACHC,EAAG,GACHC,EAAG,GACHC,EAAG,GACHC,EAAG,GACHC,EAAG,GACHC,EAAG,GACHC,EAAG,GACHC,EAAG,GACHC,EAAG,GACHC,EAAG,GACHnH,EAAG,GACHC,EAAG,GACHmH,EAAG,IAELC,cAAe,GAQfC,UAAU/E,SAAAA,EAAK2B,EAAQE,GAChBA,IACHA,GAAO,GAGLmD,IAAAA,EAAOxI,IAAI8D,OAAOyC,KAAK/C,GAEtBgF,EAKLxI,IAAI8D,OAAOwE,cAAcE,GAAQ,CAC/BrD,OAAQA,EAAOsD,KAAK,KAAMjF,GAC1B6B,KAAMA,GANNxD,QAAQC,MAAM,YAAc0G,EAAO,sBAevCE,WAAWnC,SAAAA,EAAMpB,GACfoB,EAAKhC,QAAQ,SAASf,GACpBxD,IAAI8D,OAAOyE,UAAU/E,EAAK2B,MAQ9BwD,gBAAgBxD,SAAAA,GACdnF,IAAI8D,OAAO4E,WAAW,CAAC,OAAQ,KAAM,QAAS,QAASvD,IAQzDyD,cAAcpF,SAAAA,EAAK2B,GACjBnF,IAAI8D,OAAOyE,UAAU/E,EAAK2B,GAAQ,IAOpC0D,kBAAkBrF,SAAAA,UACTxD,IAAI8D,OAAOwE,cAActI,IAAI8D,OAAOyC,KAAK/C,KAOlDsF,oBAAoBvC,SAAAA,GAClBA,EAAKhC,QAAQ,SAASf,GACpBxD,IAAI8D,OAAOiF,mBAAmBvF,MAKlCwF,yBAA2B,WACzBhJ,IAAI8D,OAAOiF,mBAAmB,CAAC,OAAQ,KAAM,QAAS,UAMxDE,cAAgB,WACdtG,SAASW,iBAAiB,UAAW,SAASC,GAC5C2F,SAAWlJ,IAAI8D,OAAOwE,cAAc/E,EAAM4F,SACtCD,WACFA,SAAS/D,SAEL+D,SAAS7D,aACJrF,IAAI8D,OAAOwE,cAAc/E,EAAM4F,aAW9CpF,4BAA4Bd,SAAAA,GACtBzC,IAAAA,EAAYyC,EAAQ,GAYjBzC,MAVN,CAAA,UAAW,YAAa,WAAY,cAAc+D,QAAQ,SAAS6E,GAEhEA,EAAI9E,MAAM,KAAK7C,MAAM,SAAS4H,GACrBpG,OAAAA,EAAQQ,QAAQ4F,IAAY,MAGrC7I,EAAY4I,KAIT5I,IAIX8I,OAAQ,CAMNC,WAAWC,SAAAA,GAGFxJ,OAFPA,IAAIqD,IAAI,OAASmG,EAAS,wBAEnBxJ,IAAIsJ,OAAOG,SAASzJ,IAAIsJ,OAAOI,WAAaF,IAOrDE,SAAW,WACFpH,OAAAA,SAASqH,aAAaC,QAAQ,WAQvCC,gBAAgBL,SAAAA,GACVM,IAAAA,EAAW3G,KAAK4G,IAAI,EAAG/J,IAAIsJ,OAAOI,WAAaF,GAG5CxJ,OAFPA,IAAIqD,IAAI,UAAYmG,EAAS,0BAEtBxJ,IAAIsJ,OAAOG,SAASK,IAQ7BL,SAASD,SAAAA,GAMAA,OALPG,aAAaK,QAAQ,QAASR,GAC9BxJ,IAAIqD,IAAI,gBAAkBmG,GAE1BxJ,IAAIsJ,OAAOW,eAEJT,GAMTS,aAAe,WACTC,IAAAA,EAAelK,IAAImK,WAAW,SAE9BD,IACFA,EAAaE,UAAYpK,IAAIsJ,OAAOI,cAK1CW,QAAS,CACPC,cAAe,GAOfC,WAAWC,SAAAA,EAAMrF,GACRsF,OAAAA,MAAM,iBAAmBD,EAAO,SAASE,KAAK,SAASC,GACxDA,EAASC,IACXD,EAASE,OAAOH,KAAK,SAASI,GAC5BnI,SAASqC,KAAK+F,UAAYD,EAC1BnI,SAASqC,KAAKgG,aAAa,QAASR,GACpCxK,IAAIqD,IAAI,eAAiBmH,GACzBxK,IAAIsJ,OAAOW,eACXjK,IAAIK,UAAUoC,oBACdzC,IAAIqK,QAAQC,cAAgBE,EAExBrF,GACFA,EAAO8F,YAWjBC,iBAAmB,WACVlL,OAAAA,IAAIqK,QAAQC,gBAIvBa,MAAO,CAOLC,gBAAgBC,SAAAA,EAAKtB,GACZ5G,OAAAA,KAAKmI,MAAMnI,KAAKoI,UAAYxB,EAAMsB,EAAM,GAAKA,KAOxDG,KAAO,WACLxL,IAAIqK,QAAQE,WAAW,QACvBvK,IAAI8D,OAAOmF,gBACXjJ,IAAIsJ,OAAOG,SAAS,IAOtBpG,IAAIoI,SAAAA,GACF5J,QAAQwB,IAAI,WAAaoI,EAAS,yCAOpCtB,WAAWuB,SAAAA,GACF/I,OAAAA,SAASC,cAAc,aAAe8I,EAAY,OAI7D3L,OAAOC,IAAIwL","file":"oxo.3b4f0104.map","sourceRoot":"../src","sourcesContent":["window.oxo = {\n  oxo: this,\n  width: window.innerWidth,\n  height: window.innerHeight,\n\n  animation: {\n    /**\n     * Modify the transform property of an element to make it move\n     * @param {HTMLElement} element - The element to move\n     * @param {string} direction - The direction\n     * @param {number} distance - The number of pixels for the move\n     * @param {allowOutside} boolean - If true, the element can go off limits\n     * @return {Object} - An object containing the updated position x and y\n     */\n    move(element, direction, distance, allowOutside) {\n      if (!element) {\n        console.error('The element to move was not found');\n        return;\n      }\n\n      if (!distance) {\n        console.error('You must provide a distance to move an element');\n        return;\n      }\n\n      var position = oxo.animation.getPosition(element);\n      var newPosition = oxo.animation.computeNewPosition(\n        position,\n        direction,\n        distance\n      );\n\n      var elPos = element.getBoundingClientRect();\n\n      if (!allowOutside) {\n        if (\n          newPosition.x + elPos.width > oxo.width ||\n          newPosition.x < 0 ||\n          newPosition.y + elPos.height > oxo.height ||\n          newPosition.y < 0\n        ) {\n          return;\n        }\n      }\n\n      if (oxo.elements.obstacles.length) {\n        var elFuturePos = Object.assign(elPos, {\n          x: newPosition.x,\n          y: newPosition.y,\n        });\n\n        if (\n          !oxo.elements.obstacles.every(function(obstacle) {\n            return (\n              obstacle == element ||\n              !oxo.elements.elementsAreColliding(\n                obstacle.getBoundingClientRect(),\n                elFuturePos\n              )\n            );\n          })\n        ) {\n          return;\n        }\n      }\n\n      oxo.animation.setPosition(element, newPosition);\n\n      return newPosition;\n    },\n\n    /**\n     * Modify a position object depending on direction and distance\n     * @param {Object} position - An object containing the x and y position\n     * @param {string} direction - The direction in which to move\n     * @param {number} distance - The distance to move\n     */\n    computeNewPosition(position, direction, distance) {\n      var newPosition = Object.assign({}, position);\n\n      switch (direction) {\n        case 'left':\n          newPosition.x -= distance;\n          break;\n        case 'left-up':\n          newPosition.y -= distance;\n          newPosition.x -= distance;\n          break;\n        case 'up':\n          newPosition.y -= distance;\n          break;\n        case 'right-up':\n          newPosition.y -= distance;\n          newPosition.x += distance;\n          break;\n        case 'right':\n          newPosition.x += distance;\n          break;\n        case 'right-down':\n          newPosition.x += distance;\n          newPosition.y += distance;\n          break;\n        case 'down':\n          newPosition.y += distance;\n          break;\n        case 'left-down':\n          newPosition.y += distance;\n          newPosition.x -= distance;\n          break;\n        default:\n          console.error(\n            'The direction provided (' + direction + ') is not valid'\n          );\n          return;\n      }\n\n      return newPosition;\n    },\n\n    /**\n     * Get the values of the translate property for the given element\n     * @param {HTMLElement} element - The element\n     * @return {Object} An object containing the x and the y position\n     */\n    getPosition(element) {\n      var position = element.style.transform.match(\n        new RegExp(/translate\\(.+\\)/)\n      );\n\n      if (position) {\n        var values = position[0].match(/-?\\d+/g).map(value => parseInt(value));\n        return {\n          x: values[0],\n          y: values[1],\n        };\n      } else {\n        return { x: 0, y: 0 };\n      }\n    },\n\n    /**\n     * Set the translate property of the given element\n     * @param {HTMLElement} element - The element to move\n     * @param {Object} position - An object containing the x and y values\n     * @return {string} - The updated transform property\n     */\n    setPosition(element, position) {\n      var transform = element.style.transform.replace(/translate\\(.+\\)/, '');\n\n      var translation = 'translate(' + position.x + 'px, ' + position.y + 'px)';\n\n      return (element.style.transform = transform + translation);\n    },\n\n    /**\n     * Search for an element that can be moved and call the adequate function\n     * @return {HTMLElement} the element moved\n     */\n    getMovableElement() {\n      var movableElement = document.querySelector('[data-oxo-movable]');\n\n      if (movableElement) {\n        var speed = movableElement.getAttribute('data-oxo-speed');\n        speed = speed ? speed : 10;\n        oxo.animation.moveElementWithArrowKeys(movableElement, speed);\n\n        return movableElement;\n      }\n    },\n\n    /**\n     * Move an element when the user press the arrow keys\n     * @param {HTMLElement} element - The element to move\n     * @param {number} speed - The speed of the movement\n     */\n    moveElementWithArrowKeys(element, speed) {\n      var interval;\n      var pressed = [];\n      var pixels = speed > 100 ? Math.round(speed / 100) : 1;\n      console.log(pixels);\n\n      document.addEventListener('keydown', function(event) {\n        if (event.key.indexOf('Arrow') === 0) {\n          var direction = event.key.replace('Arrow', '').toLowerCase();\n\n          if (pressed.indexOf(direction) === -1) {\n            pressed.push(direction);\n\n            if (!interval) {\n              interval = setInterval(function() {\n                window.requestAnimationFrame(function() {\n                  if (pressed.length) {\n                    oxo.animation.move(\n                      element,\n                      oxo.inputs.getDirectionFromPressedKeys(pressed),\n                      pixels,\n                      false\n                    );\n                  }\n                });\n              }, 100 / speed);\n            }\n          }\n        }\n      });\n\n      document.addEventListener('keyup', function(event) {\n        if (event.key.indexOf('Arrow') === 0) {\n          var direction = event.key.replace('Arrow', '').toLowerCase();\n\n          pressed = pressed.filter(key => key !== direction);\n          if (!pressed.length) {\n            clearInterval(interval);\n            interval = null;\n          }\n        }\n      });\n    },\n  },\n\n  elements: {\n    obstacles: [],\n    /**\n     * Create an HTML element\n     * @param {*} params - An object containing the element parameters\n     * @return {HTMLElement} The created element\n     */\n    createElement(params) {\n      var element = document.createElement(params.type ? params.type : 'div');\n\n      if (params.class) {\n        params.class.split(' ').forEach(function(className) {\n          element.classList.add(className);\n        });\n      }\n\n      if (params.styles) {\n        for (style in params.styles) {\n          element.style[style] = params.styles[style];\n        }\n      }\n\n      if (params.obstacle) {\n        oxo.elements.obstacles.push(element);\n      }\n\n      oxo.elements.appendElement(element, params.appendTo);\n\n      return element;\n    },\n\n    /**\n     * Append an element inside another one\n     * @param {HTMLElement} element - The element to append\n     * @param {string} hostSelector - The string to select the host element\n     */\n    appendElement(element, hostSelector) {\n      var host = hostSelector\n        ? document.querySelector(hostSelector)\n        : document.body;\n\n      if (!host) {\n        console.error('No element was found for selector ', +hostSelector);\n        return;\n      }\n\n      host.appendChild(element);\n    },\n\n    /**\n     * Execute an action when the given element collides with the border\n     * @param {HTMLElement} element - The element to observe\n     * @param {Function} action - The action to execute\n     * @param {boolean} completly - If true, the whole element must be outside\n     * @param {boolean} once - If true, the action will be executed only once\n     * @return {IntersectionObserver} - The observer\n     */\n    onLeaveScreen(element, action, completly, once) {\n      var observer = new IntersectionObserver(\n        function(entries) {\n          entries.forEach(function(entry) {\n            if (!entry.isIntersecting) {\n              action();\n\n              if (once) {\n                observer.disconnect();\n              }\n            }\n          });\n        },\n        {\n          root: null,\n          rootMargin: '0px',\n          threshold: completly ? 0 : 1,\n        }\n      );\n      observer.observe(element);\n\n      return observer;\n    },\n\n    /**\n     * Execute an action once the given element collides with the border\n     * @param {HTMLElement} element - The element to observe\n     * @param {Function} action - The action to execute\n     * @param {boolean} completly - If true, the whole element must be outside\n     * @return {IntersectionObserver} - The observer\n     */\n    onLeaveScreenOnce(element, action, completly) {\n      return oxo.elements.onLeaveScreen(element, action, completly, true);\n    },\n\n    /**\n     * Execute an action when two element collides\n     * @param {HTMLElement} element - The element to observe\n     * @param {HTMLElement} target - The element to collide with\n     * @param {Function} action - The action to execute\n     * @param {boolean} once - If true, the action is executed only once\n     * @return {Interval} - The timer used for checking\n     */\n    onCollisionWithElement(element, target, action, once) {\n      var colliding = false;\n\n      var interval = setInterval(function() {\n        if (\n          oxo.elements.elementsAreColliding(\n            element.getBoundingClientRect(),\n            target.getBoundingClientRect()\n          )\n        ) {\n          if (!colliding) {\n            action();\n            colliding = true;\n\n            if (once) {\n              clearInterval(interval);\n            }\n          }\n        } else {\n          colliding = false;\n        }\n      }, 10);\n\n      return interval;\n    },\n\n    /**\n     * Execute an action once when two element collides\n     * @param {HTMLElement} element - The element to observe\n     * @param {HTMLElement} target - The element to collide with\n     * @param {Function} action - The action to execute\n     * @return {Interval} - The timer used for checking\n     */\n    onCollisionWithElementOnce(element, target, action) {\n      return oxo.elements.onCollisionWithElement(element, target, action, true);\n    },\n\n    /**\n     * Test if two elements are in collision\n     * @param {Object} element1Pos - The first element position\n     * @param {Object} element2Pos - The second element position\n     */\n    elementsAreColliding(element1Pos, element2Pos) {\n      return (\n        element1Pos.x < element2Pos.x + element2Pos.width &&\n        element1Pos.x + element1Pos.width > element2Pos.x &&\n        element1Pos.y < element2Pos.y + element2Pos.height &&\n        element1Pos.height + element1Pos.y > element2Pos.y\n      );\n    },\n  },\n\n  inputs: {\n    keys: {\n      enter: 13,\n      space: 32,\n      left: 37,\n      up: 38,\n      right: 39,\n      down: 40,\n      a: 65,\n      b: 66,\n      c: 67,\n      d: 68,\n      e: 69,\n      f: 70,\n      g: 71,\n      h: 72,\n      i: 73,\n      j: 74,\n      k: 75,\n      l: 76,\n      m: 77,\n      n: 78,\n      o: 79,\n      p: 80,\n      q: 81,\n      r: 82,\n      s: 83,\n      t: 84,\n      u: 85,\n      v: 86,\n      w: 87,\n      x: 88,\n      y: 89,\n      z: 90,\n    },\n    keysListeners: {},\n\n    /**\n     * Execute the given action each time the given key is pressed\n     * @param {string} key - The key to press to trigger the action\n     * @param {Function} action - The function that will be executed\n     * @param {boolean} once - If true, the action will be executed only once\n     */\n    listenKey(key, action, once) {\n      if (!once) {\n        once = false;\n      }\n\n      var code = oxo.inputs.keys[key];\n\n      if (!code) {\n        console.error('The key \"' + code + '\" cannot be found');\n        return;\n      }\n\n      oxo.inputs.keysListeners[code] = {\n        action: action.bind(this, key),\n        once: once,\n      };\n    },\n\n    /**\n     * Execute the given action each time one of the given key is pressed\n     * @param {Array<string>} keys - The keys that should trigger the action\n     * @param {Function} action - The action to execute\n     */\n    listenKeys(keys, action) {\n      keys.forEach(function(key) {\n        oxo.inputs.listenKey(key, action);\n      });\n    },\n\n    /**\n     * Execute the given action each time an arrow key is pressed\n     * @param {Function} action - The action to execute\n     */\n    listenArrowKeys(action) {\n      oxo.inputs.listenKeys(['left', 'up', 'right', 'down'], action);\n    },\n\n    /**\n     * Execute the given action the next time the given key is pressed\n     * @param {string} key - The key to press to trigger the action\n     * @param {Function} action - The function that will be executed\n     * */\n    listenKeyOnce(key, action) {\n      oxo.inputs.listenKey(key, action, true);\n    },\n\n    /**\n     * Cancel the listener for the given key\n     * @param {string} key - The key to stop listening to\n     */\n    cancelKeyListener(key) {\n      delete oxo.inputs.keysListeners[oxo.inputs.keys[key]];\n    },\n\n    /**\n     * Cancel the listeners for several keys\n     * @param {Array<string>} - The keys to stop listening to\n     */\n    cancelKeysListeners(keys) {\n      keys.forEach(function(key) {\n        oxo.inputs.cancelKeysListener(key);\n      });\n    },\n\n    /** Cancel the listening of arrow keys */\n    cancelArrowKeysListeners() {\n      oxo.inputs.cancelKeysListener(['left', 'up', 'right', 'down']);\n    },\n\n    /**\n     * This method will be executed on initialization to listen all the keys\n     */\n    listenAllKeys() {\n      document.addEventListener('keydown', function(event) {\n        listener = oxo.inputs.keysListeners[event.keyCode];\n        if (listener) {\n          listener.action();\n\n          if (listener.once) {\n            delete oxo.inputs.keysListeners[event.keyCode];\n          }\n        }\n      });\n    },\n\n    /**\n     * Get the direction by combining the differents keys pressed\n     * @param {Array<string>} pressed - The direction currently pressed\n     * @return {string} the direction\n     */\n    getDirectionFromPressedKeys(pressed) {\n      var direction = pressed[0];\n\n      ['left-up', 'left-down', 'right-up', 'right-down'].forEach(function(dir) {\n        if (\n          dir.split('-').every(function(dirPart) {\n            return pressed.indexOf(dirPart) > -1;\n          })\n        ) {\n          direction = dir;\n        }\n      });\n\n      return direction;\n    },\n  },\n\n  player: {\n    /**\n     * Add one or several points to the score\n     * @param {number} points - The number of points to add\n     * @return {number} The new score\n     */\n    addToScore(points) {\n      oxo.log('Add ' + points + ' points to the score');\n\n      return oxo.player.setScore(oxo.player.getScore() + points);\n    },\n\n    /**\n     * Get the score\n     * @return {number} The score\n     */\n    getScore() {\n      return parseInt(localStorage.getItem('score'));\n    },\n\n    /**\n     * Remove one or several points from the score\n     * @param {number} points - The number of points to remove\n     * @return {number} The new score\n     */\n    removeFromScore(points) {\n      var newScore = Math.max(0, oxo.player.getScore() - points);\n      oxo.log('Remove ' + points + ' points from the score');\n\n      return oxo.player.setScore(newScore);\n    },\n\n    /**\n     * Set the score\n     * @param {number} points - The score\n     * @return {number} The score\n     */\n    setScore(points) {\n      localStorage.setItem('score', points);\n      oxo.log('New score is ' + points);\n\n      oxo.player.refreshScore();\n\n      return points;\n    },\n\n    /**\n     * Refresh the score display\n     */\n    refreshScore() {\n      var scoreElement = oxo.getElement('score');\n\n      if (scoreElement) {\n        scoreElement.innerText = oxo.player.getScore();\n      }\n    },\n  },\n\n  screens: {\n    currentScreen: '',\n    /**\n     * Load a new screen (and add matching class to the body)\n     * @param {string} name - The name of the html file for the screen to load\n     * @param {Function} action - The function to execute after loading\n     * @return {Promise} - The fetch promise\n     */\n    loadScreen(name, action) {\n      return fetch('../../screens/' + name + '.html').then(function(response) {\n        if (response.ok) {\n          response.text().then(function(html) {\n            document.body.innerHTML = html;\n            document.body.setAttribute('class', name);\n            oxo.log('Load screen ' + name);\n            oxo.player.refreshScore();\n            oxo.animation.getMovableElement();\n            oxo.screens.currentScreen = name;\n\n            if (action) {\n              action.call();\n            }\n          });\n        }\n      });\n    },\n\n    /**\n     * Get the name of the current screen\n     * @return {string} the current screen\n     */\n    getCurrentScreen() {\n      return oxo.screens.currentScreen;\n    },\n  },\n\n  utils: {\n    /**\n     * Get a random number between two limits\n     * @param {number} min - The min number\n     * @param {number} max - The max number\n     * @return {number} - The random number\n     */\n    getRandomNumber(min, max) {\n      return Math.floor(Math.random() * (max - min + 1) + min);\n    },\n  },\n\n  /**\n   * A function that will be run when oxo is called in order to init the game\n   */\n  init() {\n    oxo.screens.loadScreen('home');\n    oxo.inputs.listenAllKeys();\n    oxo.player.setScore(0);\n  },\n\n  /**\n   * Pretty logger for oxo events\n   * @param {string} message - The information to log\n   */\n  log(message) {\n    console.log('%c OXO: ' + message, 'background-color: gold; padding: 5px');\n  },\n\n  /**\n   * Find an element with an oxo data attribute in the DOM\n   * @param {string} attribute - The data attribute of the element (oxo-data-*)\n   */\n  getElement(attribute) {\n    return document.querySelector('[data-oxo-' + attribute + ']');\n  },\n};\n\nwindow.oxo.init();"]}